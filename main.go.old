package main

import "fmt"

type Point struct {
	x, y int
}

var dx = []int{1, 1, 2, 2, -1, -1, -2, -2}
var dy = []int{2, -2, 1, -1, 2, -2, 1, -1}

func isValid(x, y, X, Y int) bool {
	return x >= 0 && x < X && y >= 0 && y < Y
}

func bfs(grid [][]bool, start, finish Point) int {
	X, Y := len(grid), len(grid[0])
	queue := []Point{start}
	dist := make(map[Point]int)
	dist[start] = 0

	for len(queue) > 0 {
		curr := queue[0]
		queue = queue[1:]

		if curr == finish {
			return dist[curr]
		}

		for i := 0; i < 8; i++ {
			newX, newY := curr.x+dx[i], curr.y+dy[i]
			newPos := Point{newX, newY}
			if isValid(newX, newY, X, Y) && !grid[newX][newY] && dist[newPos] == 0 {
				dist[newPos] = dist[curr] + 1
			}
		}
	}

	return -1
}

func main() {
	var N, X, Y, P int
	fmt.Scan(&N)

	for t := 0; t < N; t++ {
		fmt.Scan(&X, &Y)
		grid := make([][]bool, X)
		for i := range grid {
			grid[i] = make([]bool, Y)
		}

		var x1, y1, x2, y2 int
		fmt.Scan(&x1, &y1, &x2, &y2)

		fmt.Scan(&P)
		for i := 0; i < P; i++ {
			var ox1, oy1, ox2, oy2 int
			fmt.Scan(&ox1, &oy1, &ox2, &oy2)

			for x := ox1; x <= ox2; x++ {
				for y := oy1; y <= oy2; y++ {
					grid[x][y] = true
				}
			}
		}

		start := Point{x1, y1}
		finish := Point{x2, y2}

		result := bfs(grid, start, finish)
		if result == -1 {
			fmt.Println("No solution.")
		} else {
			fmt.Printf("Optimal solution takes %d hops.\n", result)
		}
	}
}
